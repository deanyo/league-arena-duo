<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, viewport-fit=cover">
  <meta name="theme-color" content="#1a1621">
  <title>Arena Duo Roast</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=JetBrains+Mono:wght@400;600&family=Space+Grotesk:wght@400;600&display=swap" rel="stylesheet">
  <link rel="icon" href="data:image/svg+xml;utf8,<svg xmlns='http://www.w3.org/2000/svg' width='256' height='256' viewBox='0 0 256 256'><rect width='256' height='256' fill='%231a1621'/><text x='128' y='155' text-anchor='middle' font-family='JetBrains%20Mono,monospace' font-size='96' font-weight='600' fill='%23b3f4f3'>AD</text></svg>">
  <style>
    :root {
      --bg-0: #14111b;
      --bg-1: #1a1621;
      --bg-2: #231f32;
      --bg-3: #2a2540;
      --ink: #eee9fc;
      --muted: #9a90b3;
      --line: #3f3951;
      --accent: #b3f4f3;
      --accent-2: #e192ef;
      --accent-3: #b1f2a7;
      --warn: #f0c27b;
      --danger: #e965a5;
      --shadow: rgba(0, 0, 0, 0.35);
    }
    * { box-sizing: border-box; }
    body {
      margin: 0;
      font-family: "JetBrains Mono", "SF Mono", Consolas, monospace;
      color: var(--ink);
      background: radial-gradient(1000px 600px at 8% -20%, #2b2436, transparent),
        radial-gradient(700px 500px at 90% -10%, #1c2a35, transparent),
        linear-gradient(160deg, var(--bg-0), var(--bg-1) 40%, var(--bg-0));
      min-height: 100vh;
      padding: 24px;
    }
    body::before {
      content: "";
      position: fixed;
      inset: 0;
      background-image:
        linear-gradient(transparent 95%, rgba(255, 255, 255, 0.03)),
        linear-gradient(90deg, transparent 95%, rgba(255, 255, 255, 0.02));
      background-size: 40px 40px;
      pointer-events: none;
      opacity: 0.4;
      mix-blend-mode: screen;
    }
    .shell {
      max-width: 1080px;
      margin: 0 auto;
      position: relative;
      z-index: 1;
    }
    .hero {
      display: flex;
      gap: 24px;
      justify-content: space-between;
      align-items: flex-end;
      margin-bottom: 24px;
    }
    .hero-title {
      font-family: "Space Grotesk", "JetBrains Mono", sans-serif;
      font-size: 36px;
      letter-spacing: -0.02em;
      margin: 0 0 6px 0;
      color: var(--accent);
    }
    .hero-sub {
      margin: 0;
      color: var(--muted);
      font-size: 13px;
      text-transform: lowercase;
    }
    .hero-tag {
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 6px 12px;
      border-radius: 999px;
      border: 1px solid var(--line);
      color: var(--accent-3);
      font-size: 11px;
      text-transform: lowercase;
      background: rgba(34, 31, 50, 0.6);
      box-shadow: 0 6px 18px var(--shadow);
    }
    .hero-tag .dot {
      width: 6px;
      height: 6px;
      border-radius: 50%;
      background: currentColor;
      box-shadow: 0 0 12px currentColor;
    }
    .panel {
      background: var(--bg-2);
      border: 1px solid var(--line);
      border-radius: 12px;
      padding: 18px;
      margin-bottom: 18px;
      box-shadow: 0 10px 30px var(--shadow);
      animation: rise 0.6s ease both;
    }
    .panel.verdict-panel {
      border-color: rgba(179, 244, 243, 0.5);
      box-shadow: 0 16px 34px rgba(179, 244, 243, 0.12);
    }
    .panel-head {
      display: flex;
      justify-content: space-between;
      align-items: baseline;
      margin-bottom: 12px;
      gap: 12px;
    }
    .panel h2 {
      margin: 0;
      font-size: 13px;
      text-transform: lowercase;
      color: var(--accent);
      letter-spacing: 0.05em;
    }
    .panel-note {
      color: var(--muted);
      font-size: 11px;
    }
    .field-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }
    .field {
      display: flex;
      flex-direction: column;
      gap: 6px;
    }
    .field span {
      color: var(--muted);
      font-size: 11px;
      text-transform: lowercase;
    }
    input, select, textarea {
      background: var(--bg-1);
      border: 1px solid var(--line);
      color: var(--ink);
      padding: 8px 10px;
      border-radius: 8px;
      font-family: inherit;
      font-size: 12px;
    }
    input::placeholder, textarea::placeholder { color: var(--muted); }
    textarea {
      min-height: 72px;
      resize: vertical;
    }
    .actions {
      display: flex;
      gap: 10px;
      margin-top: 14px;
      flex-wrap: wrap;
    }
    .btn {
      background: transparent;
      border: 1px solid var(--accent);
      color: var(--accent);
      padding: 8px 14px;
      border-radius: 8px;
      font-size: 12px;
      font-family: inherit;
      cursor: pointer;
      transition: transform 0.15s ease, box-shadow 0.15s ease, border-color 0.15s ease;
      text-transform: lowercase;
    }
    .btn.primary {
      background: var(--accent);
      color: #1a1621;
      border-color: transparent;
      box-shadow: 0 10px 20px rgba(179, 244, 243, 0.2);
    }
    .btn:active {
      transform: translateY(1px);
    }
    .hint {
      font-size: 11px;
      color: var(--muted);
      margin-top: 10px;
    }
    .stat-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }
    .stat.feature {
      border-color: rgba(179, 244, 243, 0.55);
      box-shadow: 0 10px 24px rgba(179, 244, 243, 0.12);
    }
    .stat.feature .stat-value {
      font-size: 22px;
      color: var(--accent);
    }
    .stat-flag {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 2px 6px;
      border-radius: 999px;
      border: 1px solid var(--line);
      font-size: 9px;
      text-transform: uppercase;
      letter-spacing: 0.04em;
      color: var(--accent);
    }
    .stat {
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(26, 22, 33, 0.7);
    }
    .stat-label {
      color: var(--muted);
      font-size: 10px;
      text-transform: lowercase;
      margin-bottom: 6px;
    }
    .stat-value {
      font-size: 18px;
      color: var(--accent-3);
      font-weight: 600;
    }
    .stat-sub {
      font-size: 10px;
      color: var(--muted);
      margin-top: 6px;
    }
    .blame-grid {
      display: grid;
      grid-template-columns: repeat(3, minmax(0, 1fr));
      gap: 12px;
    }
    .blame-card {
      padding: 12px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(26, 22, 33, 0.65);
    }
    .blame-label {
      font-size: 11px;
      text-transform: lowercase;
      color: var(--accent-2);
    }
    .blame-value {
      font-size: 18px;
      font-weight: 600;
      margin-top: 6px;
    }
    .blame-bar {
      height: 6px;
      border-radius: 999px;
      background: rgba(255, 255, 255, 0.08);
      overflow: hidden;
      margin: 10px 0 6px;
    }
    .blame-bar span {
      display: block;
      height: 100%;
      background: linear-gradient(120deg, var(--accent-3), var(--accent));
      width: 0;
    }
    .blame-note {
      font-size: 10px;
      color: var(--muted);
    }
    .blame-breakdown {
      margin-top: 10px;
      display: grid;
      gap: 6px;
      font-size: 10px;
      color: var(--muted);
    }
    .blame-line {
      display: flex;
      justify-content: space-between;
      gap: 10px;
    }
    .blame-key {
      text-transform: lowercase;
      color: var(--muted);
    }
    .blame-val {
      color: var(--ink);
      text-align: right;
    }
    .list {
      margin: 0;
      padding: 0;
      list-style: none;
      display: grid;
      gap: 10px;
    }
    .list li {
      border: 1px solid var(--line);
      border-radius: 10px;
      padding: 10px;
      background: rgba(26, 22, 33, 0.6);
    }
    .list-title {
      font-size: 11px;
      color: var(--accent-2);
      margin-bottom: 6px;
      text-transform: lowercase;
    }
    .list-body {
      font-size: 12px;
      color: var(--ink);
    }
    .match-table {
      display: grid;
      gap: 8px;
    }
    .match-row {
      display: grid;
      grid-template-columns: 0.7fr 1fr 1fr 1.2fr;
      gap: 8px;
      padding: 10px;
      border-radius: 10px;
      border: 1px solid var(--line);
      background: rgba(20, 17, 27, 0.6);
      font-size: 11px;
      align-items: center;
    }
    .match-row strong { color: var(--ink); }
    .match-row span { color: var(--muted); }
    .chip {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid var(--line);
      text-transform: lowercase;
      font-size: 10px;
      background: rgba(26, 22, 33, 0.7);
      color: var(--muted);
      width: fit-content;
    }
    .chip.first {
      color: var(--accent);
      border-color: var(--accent);
      font-weight: 600;
    }
    .chip.top4 { color: var(--accent-3); }
    .chip.bottom4 { color: var(--danger); }
    .champ-name {
      display: inline-flex;
      align-items: center;
      gap: 4px;
    }
    .champ-name.tier-s { color: var(--accent); }
    .champ-name.tier-a { color: var(--accent-3); }
    .champ-name.tier-b { color: var(--warn); }
    .champ-name.tier-c { color: var(--muted); }
    .champ-name.tier-d { color: var(--line); }
    .verdict {
      font-size: 14px;
      line-height: 1.7;
      color: var(--ink);
      background: rgba(26, 22, 33, 0.55);
      border: 1px solid var(--line);
      padding: 14px;
      border-radius: 10px;
    }
    .footer {
      display: flex;
      justify-content: space-between;
      align-items: center;
      margin-top: 20px;
      color: var(--muted);
      font-size: 11px;
      flex-wrap: wrap;
      gap: 12px;
    }
    .footer a {
      color: var(--muted);
      text-decoration: none;
    }
    .footer a:hover { color: var(--accent); }
    .badge {
      padding: 2px 6px;
      border-radius: 6px;
      border: 1px solid var(--line);
      font-size: 10px;
      color: var(--muted);
      text-transform: lowercase;
    }
    .name-me,
    .name-duo {
      font-weight: 600;
    }
    .name-me { color: var(--accent); }
    .name-duo { color: var(--accent-2); }
    .status-warn { color: var(--warn); }
    .status-ok { color: var(--accent-3); }
    .status-bad { color: var(--danger); }
    .share-mode .lookup-panel {
      display: none;
    }
    .share-mode .panel {
      animation: none !important;
      opacity: 1 !important;
      transform: none !important;
    }
    .share-mode .panel * {
      animation: none !important;
      transition: none !important;
    }
    @keyframes rise {
      from { opacity: 0; transform: translateY(10px); }
      to { opacity: 1; transform: translateY(0); }
    }
    @media (max-width: 960px) {
      .field-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .stat-grid { grid-template-columns: repeat(2, minmax(0, 1fr)); }
      .blame-grid { grid-template-columns: 1fr; }
      .match-row { grid-template-columns: 1fr 1fr; }
    }
    @media (max-width: 640px) {
      body { padding: 16px; }
      .hero { flex-direction: column; align-items: flex-start; }
      .field-grid { grid-template-columns: 1fr; }
      .stat-grid { grid-template-columns: 1fr; }
      .match-row { grid-template-columns: 1fr; }
    }
  </style>
</head>
<body>
  <main class="shell">
    <header class="hero">
      <div>
        <h1 class="hero-title" id="duo-title">arena duo roast</h1>
        <p class="hero-sub" id="duo-sub">real stats, imaginary conclusions, arena edition</p>
      </div>
      <div class="hero-tag" id="api-tag"><span class="dot"></span><span id="api-status">demo mode</span></div>
    </header>

    <section class="panel lookup-panel" style="animation-delay: 0.05s;">
      <div class="panel-head">
        <h2>duo lookup</h2>
        <div class="panel-note">shareable url, no accounts, just vibes</div>
      </div>
      <form id="duo-form" autocomplete="off">
        <div class="field-grid">
          <label class="field">
            <span>region</span>
            <select id="region">
              <option value="na">na</option>
              <option value="euw">euw</option>
              <option value="eune">eune</option>
              <option value="kr">kr</option>
              <option value="br">br</option>
              <option value="la1">lan</option>
              <option value="la2">las</option>
              <option value="oc1">oce</option>
              <option value="tr">tr</option>
              <option value="ru">ru</option>
            </select>
          </label>
          <label class="field">
            <span>summoner</span>
            <input id="summoner-a" placeholder="example: hugegamer-EUW">
          </label>
          <label class="field">
            <span>duo</span>
            <input id="summoner-b" placeholder="example: MichyeoHEY-EUW">
          </label>
          <label class="field">
            <span>matches to scan</span>
            <select id="match-count">
              <option value="20">20 matches</option>
              <option value="25" selected>25 matches</option>
              <option value="30">30 matches</option>
            </select>
          </label>
          <label class="field">
            <span>roast tone</span>
            <select id="roast-tone">
              <option value="classic" selected>classic banter</option>
              <option value="gentle">gentle</option>
              <option value="savage">savage</option>
            </select>
          </label>
          <label class="field">
            <span>verdict style</span>
            <select id="verdict-style">
              <option value="auto">auto (cached)</option>
              <option value="fresh">fresh (no cache)</option>
              <option value="ai" selected>ai (verdict + roasts)</option>
            </select>
          </label>
        </div>
        <div class="actions">
          <button class="btn primary" type="submit" id="analyze-btn">analyze duo</button>
          <button class="btn" type="button" id="sample-btn">load sample</button>
          <button class="btn" type="button" id="share-btn">copy share url</button>
          <button class="btn" type="button" id="share-image-btn">share image</button>
          <button class="btn" type="reset" id="reset-btn">reset</button>
        </div>
      </form>
      <div class="hint" id="url-hint">share link: /?me=hugegamer-EUW&duo=MichyeoHEY-EUW&region=euw&verdict=ai</div>
    </section>

    <section class="panel" style="animation-delay: 0.1s;">
      <div class="panel-head">
        <h2>snapshot</h2>
        <div class="panel-note">recent arena data for this duo</div>
      </div>
      <div class="stat-grid">
        <div class="stat">
          <div class="stat-label">games together</div>
          <div class="stat-value" id="stat-games">--</div>
          <div class="stat-sub" id="stat-games-sub">last 25 arena games</div>
        </div>
        <div class="stat feature">
          <div class="stat-label">top 4 rate</div>
          <div class="stat-value" id="stat-winrate">--</div>
          <div class="stat-sub" id="stat-winrate-sub">top 4 / bottom 4</div>
        </div>
        <div class="stat">
          <div class="stat-label">death share</div>
          <div class="stat-value" id="stat-first">--</div>
          <div class="stat-sub" id="stat-first-sub">grey screen split</div>
        </div>
        <div class="stat">
          <div class="stat-label">damage share</div>
          <div class="stat-value" id="stat-damage">--</div>
          <div class="stat-sub" id="stat-damage-sub">me vs duo damage</div>
        </div>
        <div class="stat">
          <div class="stat-label">tank share</div>
          <div class="stat-value" id="stat-tank">--</div>
          <div class="stat-sub" id="stat-tank-sub">damage soaked split</div>
        </div>
        <div class="stat">
          <div class="stat-label">healing share</div>
          <div class="stat-value" id="stat-healing">--</div>
          <div class="stat-sub" id="stat-healing-sub">healing split</div>
        </div>
        <div class="stat">
          <div class="stat-label">shield share</div>
          <div class="stat-value" id="stat-shield">--</div>
          <div class="stat-sub" id="stat-shield-sub">shielding split</div>
        </div>
        <div class="stat">
          <div class="stat-label">streak watch</div>
          <div class="stat-value" id="stat-streak">--</div>
          <div class="stat-sub" id="stat-streak-sub">top 4 / bottom 4 streak</div>
        </div>
        <div class="stat">
          <div class="stat-label">champion pool</div>
          <div class="stat-value" id="stat-pool">--</div>
          <div class="stat-sub" id="stat-pool-sub">unique champs used</div>
        </div>
        <div class="stat">
          <div class="stat-label">meta habits</div>
          <div class="stat-value" id="stat-meta">--</div>
          <div class="stat-sub" id="stat-meta-sub">S/A usage rate</div>
        </div>
        <div class="stat">
          <div class="stat-label">comfort pick bias</div>
          <div class="stat-value" id="stat-comfort">--</div>
          <div class="stat-sub" id="stat-comfort-sub">attachment to main</div>
        </div>
        <div class="stat">
          <div class="stat-label">blame split</div>
          <div class="stat-value" id="stat-blame">--</div>
          <div class="stat-sub" id="stat-blame-sub">me / duo / riot</div>
        </div>
      </div>
    </section>

    <section class="panel verdict-panel" style="animation-delay: 0.12s;">
      <div class="panel-head">
        <h2>verdict</h2>
        <div class="panel-note">short summary of the duo vibe</div>
      </div>
      <div class="verdict" id="verdict">generate a verdict to roast responsibly.</div>
    </section>

    <section class="panel" style="animation-delay: 0.15s;">
      <div class="panel-head">
        <h2>blame engine</h2>
        <div class="panel-note">the algorithm is unbiased, mostly</div>
      </div>
      <div class="blame-grid">
        <div class="blame-card">
          <div class="blame-label name-me" id="blame-me-label">summoner</div>
          <div class="blame-value" id="blame-me">--</div>
          <div class="blame-bar"><span id="blame-me-bar"></span></div>
          <div class="blame-note" id="blame-me-note">loading data</div>
          <div class="blame-breakdown" id="blame-me-breakdown"></div>
        </div>
        <div class="blame-card">
          <div class="blame-label name-duo" id="blame-duo-label">duo</div>
          <div class="blame-value" id="blame-duo">--</div>
          <div class="blame-bar"><span id="blame-duo-bar"></span></div>
          <div class="blame-note" id="blame-duo-note">loading data</div>
          <div class="blame-breakdown" id="blame-duo-breakdown"></div>
        </div>
        <div class="blame-card">
          <div class="blame-label">riot</div>
          <div class="blame-value" id="blame-riot">--</div>
          <div class="blame-bar"><span id="blame-riot-bar"></span></div>
          <div class="blame-note" id="blame-riot-note">loading data</div>
          <div class="blame-breakdown" id="blame-riot-breakdown"></div>
        </div>
      </div>
    </section>

    <section class="panel" style="animation-delay: 0.2s;">
      <div class="panel-head">
        <h2>roast cards</h2>
        <div class="panel-note">stats are real, conclusions are vibes</div>
      </div>
      <ul class="list" id="roast-list">
        <li>
          <div class="list-title">waiting on data</div>
          <div class="list-body">run a duo lookup to generate roasts</div>
        </li>
      </ul>
    </section>

    <section class="panel" style="animation-delay: 0.25s;">
      <div class="panel-head">
        <h2>recent arena rounds</h2>
        <div class="panel-note">last games played together</div>
      </div>
      <div class="match-table" id="match-table">
        <div class="match-row">
          <strong>loading</strong>
          <span>result</span>
          <span>champions</span>
          <span>moment</span>
        </div>
      </div>
    </section>

    <footer class="footer">
      <span class="badge" id="data-source">data source: demo</span>
      <span>this site is for entertainment. stats are real. conclusions are banter.</span>
      <a href="https://github.com/deanyo" target="_blank" rel="noopener">by dnyo</a>
    </footer>
  </main>

  <script src="https://cdn.jsdelivr.net/npm/html2canvas@1.4.1/dist/html2canvas.min.js"></script>
  <script>
    const API_BASE = "https://league-arena-duo.deanryanit.workers.dev";
    const DEFAULTS = {
      region: "euw",
      me: "hugegamer-EUW",
      duo: "MichyeoHEY-EUW",
      matches: "25",
      tone: "classic",
      verdict: "ai"
    };
    const TIERLIST_URL = "./tierlist.json";
    const CHAMPION_KEY_ALIASES = {
      monkeyking: "wukong",
      nunu: "nunuwillump"
    };

    const apiStatus = document.getElementById("api-status");
    const apiTag = document.getElementById("api-tag");
    const dataSource = document.getElementById("data-source");
    const urlHint = document.getElementById("url-hint");
    const duoTitle = document.getElementById("duo-title");
    const duoSub = document.getElementById("duo-sub");
    const form = document.getElementById("duo-form");
    const sampleBtn = document.getElementById("sample-btn");
    const shareBtn = document.getElementById("share-btn");
    const shareImageBtn = document.getElementById("share-image-btn");

    const statGames = document.getElementById("stat-games");
    const statGamesSub = document.getElementById("stat-games-sub");
    const statWinrate = document.getElementById("stat-winrate");
    const statWinrateSub = document.getElementById("stat-winrate-sub");
    const statFirst = document.getElementById("stat-first");
    const statFirstSub = document.getElementById("stat-first-sub");
    const statDamage = document.getElementById("stat-damage");
    const statDamageSub = document.getElementById("stat-damage-sub");
    const statTank = document.getElementById("stat-tank");
    const statTankSub = document.getElementById("stat-tank-sub");
    const statHealing = document.getElementById("stat-healing");
    const statHealingSub = document.getElementById("stat-healing-sub");
    const statShield = document.getElementById("stat-shield");
    const statShieldSub = document.getElementById("stat-shield-sub");
    const statStreak = document.getElementById("stat-streak");
    const statStreakSub = document.getElementById("stat-streak-sub");
    const statPool = document.getElementById("stat-pool");
    const statPoolSub = document.getElementById("stat-pool-sub");
    const statMeta = document.getElementById("stat-meta");
    const statMetaSub = document.getElementById("stat-meta-sub");
    const statComfort = document.getElementById("stat-comfort");
    const statComfortSub = document.getElementById("stat-comfort-sub");
    const statBlame = document.getElementById("stat-blame");
    const statBlameSub = document.getElementById("stat-blame-sub");

    const blameMe = document.getElementById("blame-me");
    const blameMeBar = document.getElementById("blame-me-bar");
    const blameMeLabel = document.getElementById("blame-me-label");
    const blameMeNote = document.getElementById("blame-me-note");
    const blameMeBreakdown = document.getElementById("blame-me-breakdown");
    const blameDuo = document.getElementById("blame-duo");
    const blameDuoBar = document.getElementById("blame-duo-bar");
    const blameDuoLabel = document.getElementById("blame-duo-label");
    const blameDuoNote = document.getElementById("blame-duo-note");
    const blameDuoBreakdown = document.getElementById("blame-duo-breakdown");
    const blameRiot = document.getElementById("blame-riot");
    const blameRiotBar = document.getElementById("blame-riot-bar");
    const blameRiotNote = document.getElementById("blame-riot-note");
    const blameRiotBreakdown = document.getElementById("blame-riot-breakdown");

    const roastList = document.getElementById("roast-list");
    const matchTable = document.getElementById("match-table");
    const verdict = document.getElementById("verdict");

    let tierMap = new Map();
    let tierListLoaded = false;
    let tierListNames = [];
    let lastData = null;
    let lastChampionNames = [];

    const demoData = {
      meta: {
        source: "demo",
        updatedAt: "just now",
        matchCount: 25,
        duo: { me: "hugegamer", duo: "MichyeoHEY", region: "euw" }
      },
      summary: {
        games: 22,
        wins: 13,
        winRate: 0.59,
        avgPlacement: 2.4,
        firsts: 4,
        firstRate: "18%",
        firstDeaths: { me: 5, duo: 9 },
        comfortBias: "MichyeoHEY",
        comfortPick: "jinx",
        duoIdentity: "all-in adventurers"
      },
      insights: {
        streaks: { top4: 4, bottom4: 2 },
        deaths: { me: 19, duo: 21 },
        damage: { me: 112345, duo: 131890, total: 244235 },
        damageTaken: { me: 158900, duo: 132400, total: 291300 },
        healing: { me: 5200, duo: 4800, total: 10000 },
        shielding: { me: 1800, duo: 2200, total: 4000 },
        support: { me: 7000, duo: 7000, total: 14000 },
        shares: {
          deaths: { me: 0.48, duo: 0.52 },
          damage: { me: 0.46, duo: 0.54 },
          tank: { me: 0.55, duo: 0.45 },
          healing: { me: 0.52, duo: 0.48 },
          shielding: { me: 0.45, duo: 0.55 },
          support: { me: 0.5, duo: 0.5 }
        },
        diversity: { me: 9, duo: 12, combined: 14 },
        meta: {
          me: { metaRate: 0.62 },
          duo: { metaRate: 0.48 }
        }
      },
      blame: {
        me: {
          share: 0.34,
          reason: "death share (48%)",
          breakdown: [
            { label: "execution", value: "deaths 19 (48%)" },
            { label: "impact", value: "damage share 48%" },
            { label: "healing", value: "healing 5,200 (52%)" },
            { label: "shielding", value: "shielding 1,800 (45%)" },
            { label: "economy", value: "low items 22%" },
            { label: "meta", value: "S/A picks 41%" }
          ]
        },
        duo: {
          share: 0.41,
          reason: "damage share (52%)",
          breakdown: [
            { label: "execution", value: "deaths 21 (52%)" },
            { label: "impact", value: "damage share 52%" },
            { label: "healing", value: "healing 4,800 (48%)" },
            { label: "shielding", value: "shielding 2,200 (55%)" },
            { label: "economy", value: "low items 28%" },
            { label: "meta", value: "S/A picks 55%" }
          ]
        },
        riot: {
          share: 0.25,
          reason: "volatility tax",
          breakdown: [
            { label: "volatility", value: "placement swing 1.42 (higher = swingier)" },
            { label: "close exits", value: "5th-6th finishes 5 (20%)" },
            { label: "early exits", value: "7th-8th finishes 2 (8%)" }
          ]
        }
      },
      roasts: [
        { title: "death share", body: "deaths are split down the middle. shared suffering, shared blame." },
        { title: "streak watch", body: "top 4 streak hit 4. momentum is real." },
        { title: "comfort lock", body: "jinx shows up in every other match. comfort pick or lifestyle choice." },
        { title: "clutch moments", body: "hugegamer secures the last takedown in 8 rounds. hero arc confirmed." }
      ],
      matches: [
        { result: "first", resultLabel: "1st", placement: 1, champs: "yasuo + jinx", highlight: "top spot secured" },
        { result: "top4", resultLabel: "top 4", placement: 4, champs: "ahri + jinx", highlight: "top 4 secured" },
        { result: "top4", resultLabel: "top 4", placement: 2, champs: "pantheon + jinx", highlight: "setup for days" },
        { result: "top4", resultLabel: "top 4", placement: 3, champs: "lucian + jinx", highlight: "survived the chaos" },
        { result: "first", resultLabel: "1st", placement: 1, champs: "vi + jinx", highlight: "first place sealed" }
      ],
      verdict: "hugegamer and MichyeoHEY are landing top 4 in 59% across 22 arena games, with 4 first-place wins and an average placement of 2.4. arena scoring: top 4 of 8 teams is a win, first place is the top spot. the data suggests MichyeoHEY leans on jinx, while riot keeps the augment wheel spicy. the vibe says you are one good roll away from dominance."
    };

    function setStatus(text, tone) {
      apiStatus.textContent = text;
      apiTag.classList.remove("status-warn", "status-ok", "status-bad");
      if (tone) apiTag.classList.add(tone);
    }

    function clearList(listEl) {
      while (listEl.firstChild) listEl.removeChild(listEl.firstChild);
    }

    function formatPercent(value) {
      return Math.round(value * 100) + "%";
    }

    function formatNumber(value) {
      const num = Number(value);
      if (!Number.isFinite(num)) return "0";
      return Math.round(num).toLocaleString("en-US");
    }

    function displayNameFromInput(value) {
      const trimmed = (value || "").trim();
      if (!trimmed) return "";
      if (trimmed.includes("#")) {
        return trimmed.split("#")[0].trim();
      }
      const dashIndex = trimmed.lastIndexOf("-");
      if (dashIndex > 0) {
        const tag = trimmed.slice(dashIndex + 1).trim();
        if (/^[A-Za-z0-9]{2,5}$/.test(tag)) {
          return trimmed.slice(0, dashIndex).trim();
        }
      }
      return trimmed;
    }

    function normalizeVerdictStyle(value) {
      const cleaned = (value || "").trim().toLowerCase();
      if (cleaned === "fresh" || cleaned === "manual") return "fresh";
      if (cleaned === "ai") return "ai";
      return "auto";
    }

    function escapeHtml(value) {
      return String(value).replace(/[&<>"']/g, (char) => {
        const map = {
          "&": "&amp;",
          "<": "&lt;",
          ">": "&gt;",
          "\"": "&quot;",
          "'": "&#39;"
        };
        return map[char] || char;
      });
    }

    function escapeRegExp(value) {
      return String(value).replace(/[.*+?^${}()|[\]\\]/g, "\\$&");
    }

    function normalizeChampionKey(name) {
      const key = String(name || "").toLowerCase().replace(/[^a-z0-9]/g, "");
      return CHAMPION_KEY_ALIASES[key] || key;
    }

    function buildTierMap(data) {
      const map = new Map();
      const tiers = (data && data.tiers) || {};
      Object.entries(tiers).forEach(([tier, list]) => {
        if (!Array.isArray(list)) return;
        list.forEach((champion) => {
          const key = normalizeChampionKey(champion);
          if (key) map.set(key, tier);
        });
      });
      return map;
    }

    function extractTierNames(data) {
      const names = [];
      const tiers = (data && data.tiers) || {};
      Object.values(tiers).forEach((list) => {
        if (!Array.isArray(list)) return;
        list.forEach((name) => {
          if (name) names.push(name);
        });
      });
      return names;
    }

    function getChampionTier(name) {
      if (!tierListLoaded || !name) return null;
      const key = normalizeChampionKey(name);
      return tierMap.get(key) || null;
    }

    function renderChampionList(container, champsText) {
      container.textContent = "";
      const raw = String(champsText || "").trim();
      if (!raw) return;
      const parts = raw.split(/\s*\+\s*/).map((part) => part.trim()).filter(Boolean);
      parts.forEach((champion, index) => {
        if (index > 0) {
          container.appendChild(document.createTextNode(" + "));
        }
        const champSpan = document.createElement("span");
        const tier = getChampionTier(champion);
        champSpan.className = tier ? "champ-name tier-" + tier.toLowerCase() : "champ-name";
        champSpan.textContent = tier ? `${champion} [${tier}]` : champion;
        container.appendChild(champSpan);
      });
    }

    function extractChampionNames(data) {
      const names = new Set();
      if (data?.summary?.comfortPick) {
        names.add(data.summary.comfortPick);
      }
      (data?.matches || []).forEach((match) => {
        if (!match || !match.champs) return;
        String(match.champs)
          .split(/\s*\+\s*/)
          .map((part) => part.trim())
          .filter(Boolean)
          .forEach((name) => names.add(name));
      });
      return Array.from(names);
    }

    function isBoundaryChar(char) {
      return !char || !/[A-Za-z0-9]/.test(char);
    }

    function isBoundary(text, start, end) {
      return isBoundaryChar(text[start - 1]) && isBoundaryChar(text[end]);
    }

    function findNextMarker(text, lowerText, start, markers) {
      let best = null;
      markers.forEach((marker) => {
        let idx = lowerText.indexOf(marker.valueLower, start);
        while (idx !== -1) {
          const end = idx + marker.length;
          if (isBoundary(text, idx, end)) {
            const rank = marker.type === "player" ? 2 : 1;
            if (
              !best ||
              idx < best.index ||
              (idx === best.index && (marker.length > best.length || (marker.length === best.length && rank > best.rank)))
            ) {
              best = { ...marker, index: idx, length: marker.length, rank };
            }
            break;
          }
          idx = lowerText.indexOf(marker.valueLower, idx + 1);
        }
      });
      return best;
    }

    function renderDecoratedText(target, text, names, championNames) {
      target.textContent = "";
      if (!text) return;
      const markers = [];
      if (names?.me) markers.push({ value: names.me, valueLower: names.me.toLowerCase(), length: names.me.length, type: "player", className: "name-me" });
      if (names?.duo) markers.push({ value: names.duo, valueLower: names.duo.toLowerCase(), length: names.duo.length, type: "player", className: "name-duo" });
      (championNames || []).forEach((name) => {
        const tier = getChampionTier(name);
        if (!tier) return;
        markers.push({ value: name, valueLower: name.toLowerCase(), length: name.length, type: "champ", tier });
      });
      if (!markers.length) {
        target.textContent = text;
        return;
      }
      const lowerText = text.toLowerCase();
      let cursor = 0;
      while (cursor < text.length) {
        const match = findNextMarker(text, lowerText, cursor, markers);
        if (!match) {
          target.appendChild(document.createTextNode(text.slice(cursor)));
          break;
        }
        if (match.index > cursor) {
          target.appendChild(document.createTextNode(text.slice(cursor, match.index)));
        }
        const fragment = text.slice(match.index, match.index + match.length);
        if (match.type === "player") {
          const span = document.createElement("span");
          span.className = match.className;
          span.textContent = fragment;
          target.appendChild(span);
        } else {
          const span = document.createElement("span");
          span.className = "champ-name tier-" + match.tier.toLowerCase();
          span.textContent = `${fragment} [${match.tier}]`;
          target.appendChild(span);
        }
        cursor = match.index + match.length;
      }
    }

    async function loadTierList() {
      try {
        const response = await fetch(TIERLIST_URL);
        if (!response.ok) return;
        const data = await response.json();
        tierMap = buildTierMap(data);
        tierListLoaded = true;
        tierListNames = extractTierNames(data);
        if (lastData) renderAll(lastData);
      } catch (error) {
        tierListLoaded = false;
      }
    }

    function highlightNames(text, names) {
      if (!text) return "";
      const namePairs = [
        { value: names.me, className: "name-me" },
        { value: names.duo, className: "name-duo" }
      ]
        .filter((entry) => entry.value)
        .sort((a, b) => b.value.length - a.value.length);

      let output = escapeHtml(text);
      namePairs.forEach((entry) => {
        const safeName = escapeHtml(entry.value);
        if (!safeName) return;
        const regex = new RegExp(escapeRegExp(safeName), "gi");
        output = output.replace(regex, (match) => `<span class="${entry.className}">${match}</span>`);
      });
      return output;
    }

    function formatDuoTitle(names) {
      const me = names && names.me ? escapeHtml(names.me) : "me";
      const duo = names && names.duo ? escapeHtml(names.duo) : "duo";
      return `<span class="name-me">${me}</span> + <span class="name-duo">${duo}</span>`;
    }

    function leaderLabel(meValue, duoValue, meName, duoName) {
      if (meValue === duoValue) return "tied";
      return meValue > duoValue ? meName : duoName;
    }

    function shareSummary(shares, names, tieMargin = 0.0001) {
      const meShare = typeof shares?.me === "number" ? shares.me : 0;
      const duoShare = typeof shares?.duo === "number" ? shares.duo : 0;
      if (meShare <= 0 && duoShare <= 0) {
        return { leader: "no data", detail: "combat stats missing" };
      }
      if (Math.abs(meShare - duoShare) <= tieMargin) {
        return {
          leader: "tied",
          detail: `${names.me} ${formatPercent(meShare)} vs ${names.duo} ${formatPercent(duoShare)}`
        };
      }
      return {
        leader: meShare > duoShare ? names.me : names.duo,
        detail: `${names.me} ${formatPercent(meShare)} vs ${names.duo} ${formatPercent(duoShare)}`
      };
    }

    function renderSummary(data) {
      const summary = data.summary;
      const meta = data.meta;
      const matches = Array.isArray(data.matches) ? data.matches : [];
      const insights = data.insights || {};
      const shares = insights.shares || {};
      const streaks = insights.streaks || {};
      const diversity = insights.diversity || {};
      const metaStats = insights.meta || null;
      const safeFirsts = Number.isFinite(summary.firsts)
        ? summary.firsts
        : matches.filter((match) => (match.placement || 0) === 1).length;
      statGames.textContent = summary.games + " games";
      statGamesSub.textContent = "last " + meta.matchCount + " arena games";
      statWinrate.textContent = formatPercent(summary.winRate);
      statWinrateSub.innerHTML = `${summary.wins} top 4 / ${summary.games - summary.wins} bottom 4 Â· <span class="stat-flag">${safeFirsts} wins</span>`;
      const deathSummary = shareSummary(shares.deaths, meta.duo);
      const deathsTotal = (insights.deaths?.me || 0) + (insights.deaths?.duo || 0);
      statFirst.innerHTML = highlightNames(deathSummary.leader, meta.duo);
      if (deathsTotal > 0) {
        statFirstSub.innerHTML = highlightNames(
          meta.duo.me +
            " " +
            (insights.deaths?.me || 0) +
            " (" +
            formatPercent(shares.deaths?.me || 0) +
            ") vs " +
            meta.duo.duo +
            " " +
            (insights.deaths?.duo || 0) +
            " (" +
            formatPercent(shares.deaths?.duo || 0) +
            ")",
          meta.duo
        );
      } else {
        statFirstSub.textContent = "no combat data";
      }
      const damageTotal = Number(insights.damage?.total || 0);
      if (damageTotal > 0) {
        const damageSummary = shareSummary(shares.damage, meta.duo);
        statDamage.innerHTML = highlightNames(damageSummary.leader, meta.duo);
        statDamageSub.innerHTML = highlightNames(
          meta.duo.me +
            " " +
            formatNumber(insights.damage?.me || 0) +
            " (" +
            formatPercent(shares.damage?.me || 0) +
            ") vs " +
            meta.duo.duo +
            " " +
            formatNumber(insights.damage?.duo || 0) +
            " (" +
            formatPercent(shares.damage?.duo || 0) +
            ")",
          meta.duo
        );
      } else {
        statDamage.textContent = "none";
        statDamageSub.textContent = "no damage logged";
      }
      const tankTotal = Number(insights.damageTaken?.total || 0);
      if (tankTotal > 0) {
        const tankSummary = shareSummary(shares.tank, meta.duo);
        statTank.innerHTML = highlightNames(tankSummary.leader, meta.duo);
        statTankSub.innerHTML = highlightNames(
          meta.duo.me +
            " " +
            formatNumber(insights.damageTaken?.me || 0) +
            " (" +
            formatPercent(shares.tank?.me || 0) +
            ") vs " +
            meta.duo.duo +
            " " +
            formatNumber(insights.damageTaken?.duo || 0) +
            " (" +
            formatPercent(shares.tank?.duo || 0) +
            ")",
          meta.duo
        );
      } else {
        statTank.textContent = "none";
        statTankSub.textContent = "no damage taken logged";
      }
      const healingTotal = Number(insights.healing?.total || 0);
      if (healingTotal > 0) {
        const healingSummary = shareSummary(shares.healing, meta.duo);
        statHealing.innerHTML = highlightNames(healingSummary.leader, meta.duo);
        statHealingSub.innerHTML = highlightNames(
          meta.duo.me +
            " " +
            formatNumber(insights.healing?.me || 0) +
            " (" +
            formatPercent(shares.healing?.me || 0) +
            ") vs " +
            meta.duo.duo +
            " " +
            formatNumber(insights.healing?.duo || 0) +
            " (" +
            formatPercent(shares.healing?.duo || 0) +
            ")",
          meta.duo
        );
      } else {
        statHealing.textContent = "none";
        statHealingSub.textContent = "no healing logged";
      }
      const shieldTotal = Number(insights.shielding?.total || 0);
      if (shieldTotal > 0) {
        const shieldSummary = shareSummary(shares.shielding, meta.duo);
        statShield.innerHTML = highlightNames(shieldSummary.leader, meta.duo);
        statShieldSub.innerHTML = highlightNames(
          meta.duo.me +
            " " +
            formatNumber(insights.shielding?.me || 0) +
            " (" +
            formatPercent(shares.shielding?.me || 0) +
            ") vs " +
            meta.duo.duo +
            " " +
            formatNumber(insights.shielding?.duo || 0) +
            " (" +
            formatPercent(shares.shielding?.duo || 0) +
            ")",
          meta.duo
        );
      } else {
        statShield.textContent = "none";
        statShieldSub.textContent = "no shielding logged";
      }
      const top4Streak = Number(streaks.top4 || 0);
      const bottom4Streak = Number(streaks.bottom4 || 0);
      if (top4Streak === 0 && bottom4Streak === 0) {
        statStreak.textContent = "no streak";
      } else if (top4Streak >= bottom4Streak) {
        statStreak.textContent = "top 4 x" + top4Streak;
      } else {
        statStreak.textContent = "bottom 4 x" + bottom4Streak;
      }
      statStreakSub.textContent = "top 4 " + top4Streak + " / bottom 4 " + bottom4Streak;
      const poolTotal = Number(diversity.combined || 0);
      statPool.textContent = poolTotal ? poolTotal + " champs" : "--";
      statPoolSub.textContent = "me " + (diversity.me || 0) + " / duo " + (diversity.duo || 0);
      if (!metaStats) {
        statMeta.textContent = "tier list offline";
        statMetaSub.textContent = "no meta data";
      } else {
        const meRate = metaStats.me?.metaRate || 0;
        const duoRate = metaStats.duo?.metaRate || 0;
        const meTotal = metaStats.me?.total || summary.games || 0;
        const duoTotal = metaStats.duo?.total || summary.games || 0;
        const meMetaCount = Math.round(meRate * meTotal);
        const duoMetaCount = Math.round(duoRate * duoTotal);
        const metaLeader = Math.abs(meRate - duoRate) <= 0.06
          ? "balanced"
          : meRate > duoRate
            ? meta.duo.me
            : meta.duo.duo;
        statMeta.innerHTML = highlightNames(metaLeader, meta.duo);
        statMetaSub.innerHTML = highlightNames(
          meta.duo.me +
            " " +
            meMetaCount +
            "/" +
            meTotal +
            " (" +
            formatPercent(meRate) +
            ") vs " +
            meta.duo.duo +
            " " +
            duoMetaCount +
            "/" +
            duoTotal +
            " (" +
            formatPercent(duoRate) +
            ") meta",
          meta.duo
        );
      }
      statComfort.innerHTML = highlightNames(summary.comfortBias, meta.duo);
      statComfortSub.textContent = "most played: ";
      const comfortSpan = document.createElement("span");
      renderChampionList(comfortSpan, summary.comfortPick);
      statComfortSub.appendChild(comfortSpan);
      const blame = data.blame;
      statBlame.textContent = Math.round(blame.me.share * 100) + " / " + Math.round(blame.duo.share * 100) + " / " + Math.round(blame.riot.share * 100);
      statBlameSub.textContent = "me / duo / riot";
    }

    function renderBlame(data) {
      const blame = data.blame;
      blameMeLabel.textContent = data.meta.duo.me;
      blameDuoLabel.textContent = data.meta.duo.duo;

      blameMe.textContent = formatPercent(blame.me.share);
      blameMeBar.style.width = Math.round(blame.me.share * 100) + "%";
      blameMeNote.textContent = blame.me.reason;

      blameDuo.textContent = formatPercent(blame.duo.share);
      blameDuoBar.style.width = Math.round(blame.duo.share * 100) + "%";
      blameDuoNote.textContent = blame.duo.reason;

      blameRiot.textContent = formatPercent(blame.riot.share);
      blameRiotBar.style.width = Math.round(blame.riot.share * 100) + "%";
      blameRiotNote.textContent = blame.riot.reason;

      renderBlameBreakdown(blameMeBreakdown, blame.me.breakdown || [], data.meta.duo);
      renderBlameBreakdown(blameDuoBreakdown, blame.duo.breakdown || [], data.meta.duo);
      renderBlameBreakdown(blameRiotBreakdown, blame.riot.breakdown || [], null);
    }

    function renderRoasts(roasts, names, championNames) {
      clearList(roastList);
      roasts.forEach((roast) => {
        const item = document.createElement("li");
        const title = document.createElement("div");
        title.className = "list-title";
        title.textContent = roast.title;
        const body = document.createElement("div");
        body.className = "list-body";
        renderDecoratedText(body, roast.body, names, championNames);
        item.append(title, body);
        roastList.appendChild(item);
      });
    }

    function renderBlameBreakdown(container, breakdown, names) {
      while (container.firstChild) container.removeChild(container.firstChild);
      if (!breakdown || breakdown.length === 0) {
        const empty = document.createElement("div");
        empty.className = "blame-line";
        empty.textContent = "no details";
        container.appendChild(empty);
        return;
      }
      breakdown.forEach((entry) => {
        const row = document.createElement("div");
        row.className = "blame-line";
        const label = document.createElement("span");
        label.className = "blame-key";
        label.textContent = entry.label || "detail";
        const value = document.createElement("span");
        value.className = "blame-val";
        if (names) {
          value.innerHTML = highlightNames(entry.value || "--", names);
        } else {
          value.textContent = entry.value || "--";
        }
        row.append(label, value);
        container.appendChild(row);
      });
    }

    function renderMatches(matches) {
      clearList(matchTable);
      const head = document.createElement("div");
      head.className = "match-row";
      head.innerHTML = "<strong>result</strong><span>placement</span><span>champions</span><span>moment</span>";
      matchTable.appendChild(head);
      matches.forEach((match) => {
        const row = document.createElement("div");
        row.className = "match-row";
        const result = document.createElement("div");
        const placementValue = match.placement || 0;
        const resultType = placementValue === 1
          ? "first"
          : placementValue > 1 && placementValue <= 4
            ? "top4"
            : placementValue >= 5
              ? "bottom4"
              : match.result || "bottom4";
        const labelMap = {
          first: "1st",
          top4: "top 4",
          bottom4: "bottom 4",
          win: "top 4",
          loss: "bottom 4"
        };
        const classMap = {
          first: "first",
          top4: "top4",
          bottom4: "bottom4",
          win: "top4",
          loss: "bottom4"
        };
        const displayLabel = match.resultLabel || labelMap[resultType] || String(resultType);
        result.className = "chip " + (classMap[resultType] || "bottom4");
        result.textContent = displayLabel;
        const placement = document.createElement("span");
        placement.textContent = "place " + match.placement;
        const champs = document.createElement("span");
        renderChampionList(champs, match.champs);
        const highlight = document.createElement("span");
        highlight.textContent = match.highlight;
        row.append(result, placement, champs, highlight);
        matchTable.appendChild(row);
      });
    }

    function renderErrorState(message, params) {
      const safeMessage = message ? String(message) : "api error";
      const names = {
        me: params && params.me ? params.me : DEFAULTS.me,
        duo: params && params.duo ? params.duo : DEFAULTS.duo
      };
      const displayNames = {
        me: displayNameFromInput(names.me) || names.me,
        duo: displayNameFromInput(names.duo) || names.duo
      };
      const region = params && params.region ? params.region : DEFAULTS.region;

      setStatus("api error", "status-bad");
      dataSource.textContent = "data source: error";
      duoTitle.innerHTML = formatDuoTitle(displayNames);
      duoSub.textContent = "arena duo report for " + region.toUpperCase();

      statGames.textContent = "--";
      statGamesSub.textContent = "no data";
      statWinrate.textContent = "--";
      statWinrateSub.textContent = safeMessage;
      statFirst.textContent = "--";
      statFirstSub.textContent = "no data";
      statDamage.textContent = "--";
      statDamageSub.textContent = "no data";
      statTank.textContent = "--";
      statTankSub.textContent = "no data";
      statHealing.textContent = "--";
      statHealingSub.textContent = "no data";
      statShield.textContent = "--";
      statShieldSub.textContent = "no data";
      statStreak.textContent = "--";
      statStreakSub.textContent = "no data";
      statPool.textContent = "--";
      statPoolSub.textContent = "no data";
      statMeta.textContent = "--";
      statMetaSub.textContent = "no data";
      statComfort.textContent = "--";
      statComfortSub.textContent = "no data";
      statBlame.textContent = "--";
      statBlameSub.textContent = "me / duo / riot";

      blameMeLabel.textContent = displayNames.me;
      blameDuoLabel.textContent = displayNames.duo;
      blameMe.textContent = "--";
      blameMeBar.style.width = "0%";
      blameMeNote.textContent = "api error";
      blameDuo.textContent = "--";
      blameDuoBar.style.width = "0%";
      blameDuoNote.textContent = "api error";
      blameRiot.textContent = "--";
      blameRiotBar.style.width = "0%";
      blameRiotNote.textContent = "api error";
      blameMeBreakdown.textContent = "no data";
      blameDuoBreakdown.textContent = "no data";
      blameRiotBreakdown.textContent = "no data";

      clearList(roastList);
      const roastItem = document.createElement("li");
      const roastTitle = document.createElement("div");
      roastTitle.className = "list-title";
      roastTitle.textContent = "api error";
      const roastBody = document.createElement("div");
      roastBody.className = "list-body";
      roastBody.textContent = safeMessage;
      roastItem.append(roastTitle, roastBody);
      roastList.appendChild(roastItem);

      clearList(matchTable);
      const row = document.createElement("div");
      row.className = "match-row";
      row.innerHTML = "<strong>error</strong><span>--</span><span>--</span><span>check api key</span>";
      matchTable.appendChild(row);

      verdict.textContent = safeMessage;
    }

    function renderVerdict(text, names, championNames) {
      const safeText = text || "no verdict yet";
      renderDecoratedText(verdict, safeText, names, championNames);
    }

    function renderMeta(data) {
      const source = data.meta.source || "api";
      const verdictMode = data.meta.verdictSource || normalizeVerdictStyle(document.getElementById("verdict-style").value);
      const roastsMode = data.meta.roastsSource || "auto";
      const momentsMode = data.meta.momentsSource || "auto";
      const verdictLabel = verdictMode === "fresh"
        ? "fresh verdict"
        : verdictMode === "ai" || verdictMode === "ai-cache"
          ? "ai verdict"
          : verdictMode === "ai-fallback"
            ? "fallback verdict"
            : "";
      const roastsLabel = roastsMode === "ai" || roastsMode === "ai-cache"
        ? "ai roasts"
        : roastsMode === "ai-fallback"
          ? "fallback roasts"
          : "";
      const momentsLabel = momentsMode === "ai" || momentsMode === "ai-cache"
        ? "ai moments"
        : momentsMode === "ai-fallback"
          ? "fallback moments"
          : "";
      const labels = [];
      if (verdictLabel) labels.push(verdictLabel);
      if (roastsLabel) labels.push(roastsLabel);
      if (momentsLabel) labels.push(momentsLabel);

      let statusText = source === "demo" ? "demo mode" : source === "cache" ? "cached stats" : "live data";
      if (labels.length) {
        statusText = statusText + " Â· " + labels.join(" Â· ");
      }
      setStatus(statusText, source === "demo" ? "status-warn" : "status-ok");
      const sourceText = labels.length ? `${source} (${labels.join(" Â· ")})` : source;
      dataSource.textContent = "data source: " + sourceText;
      duoTitle.innerHTML = formatDuoTitle(data.meta.duo);
      duoSub.textContent = "arena duo report for " + data.meta.duo.region.toUpperCase();
    }

    function renderAll(data) {
      lastData = data;
      lastChampionNames = tierListLoaded && tierListNames.length
        ? tierListNames
        : extractChampionNames(data);
      renderMeta(data);
      renderSummary(data);
      renderBlame(data);
      renderRoasts(data.roasts || [], data.meta.duo, lastChampionNames);
      renderMatches(data.matches || []);
      renderVerdict(data.verdict || "", data.meta.duo, lastChampionNames);
    }

    function normalizeInput(value, fallback) {
      const trimmed = (value || "").trim();
      return trimmed ? trimmed : fallback;
    }

    function collectParams() {
      return {
        region: document.getElementById("region").value,
        me: normalizeInput(document.getElementById("summoner-a").value, DEFAULTS.me),
        duo: normalizeInput(document.getElementById("summoner-b").value, DEFAULTS.duo),
        matches: document.getElementById("match-count").value,
        tone: document.getElementById("roast-tone").value,
        verdict: normalizeVerdictStyle(document.getElementById("verdict-style").value)
      };
    }

    function applyParams(params) {
      document.getElementById("region").value = params.region;
      document.getElementById("summoner-a").value = params.me;
      document.getElementById("summoner-b").value = params.duo;
      document.getElementById("match-count").value = params.matches;
      document.getElementById("roast-tone").value = params.tone;
      document.getElementById("verdict-style").value = params.verdict;
    }

    function paramsFromUrl() {
      const url = new URL(window.location.href);
      return {
        region: url.searchParams.get("region") || DEFAULTS.region,
        me: url.searchParams.get("me") || DEFAULTS.me,
        duo: url.searchParams.get("duo") || DEFAULTS.duo,
        matches: url.searchParams.get("matches") || DEFAULTS.matches,
        tone: url.searchParams.get("tone") || DEFAULTS.tone,
        verdict: normalizeVerdictStyle(url.searchParams.get("verdict") || DEFAULTS.verdict)
      };
    }

    function updateUrl(params) {
      const url = new URL(window.location.href);
      url.searchParams.set("region", params.region);
      url.searchParams.set("me", params.me);
      url.searchParams.set("duo", params.duo);
      url.searchParams.set("matches", params.matches);
      url.searchParams.set("tone", params.tone);
      url.searchParams.set("verdict", params.verdict);
      history.replaceState(null, "", url.toString());
      urlHint.textContent = "share link: " + url.pathname + url.search;
      return url.toString();
    }

    async function fetchDuoData(params) {
      if (!API_BASE) {
        throw new Error("API not configured");
      }
      const url = new URL(API_BASE.replace(/\/$/, "") + "/duo");
      url.searchParams.set("region", params.region);
      url.searchParams.set("me", params.me);
      url.searchParams.set("duo", params.duo);
      url.searchParams.set("matches", params.matches);
      url.searchParams.set("tone", params.tone);
      url.searchParams.set("verdict", params.verdict);
      const response = await fetch(url.toString(), {
        headers: { "Accept": "application/json" }
      });
      if (!response.ok) {
        let message = "api error";
        try {
          const payload = await response.json();
          if (payload && payload.error) {
            message = String(payload.error);
          }
        } catch (error) {
          message = "api error";
        }
        throw new Error(message);
      }
      return response.json();
    }

    async function shareReportImage() {
      if (!window.html2canvas) {
        setStatus("image export not available", "status-bad");
        return;
      }
      const reportNode = document.querySelector(".shell");
      if (!reportNode) {
        setStatus("image export failed", "status-bad");
        return;
      }
      const params = collectParams();
      const displayNames = {
        me: displayNameFromInput(params.me) || params.me,
        duo: displayNameFromInput(params.duo) || params.duo
      };
      const fileBase = `${displayNames.me}-${displayNames.duo}`.replace(/[^A-Za-z0-9-_]+/g, "_");
      document.body.classList.add("share-mode");
      try {
        if (document.fonts && document.fonts.ready) {
          await document.fonts.ready;
        }
        await new Promise((resolve) => requestAnimationFrame(resolve));
        const scale = Math.min(2, window.devicePixelRatio || 1);
        const canvas = await window.html2canvas(reportNode, {
          backgroundColor: "#14111b",
          scale,
          useCORS: true
        });
        const blob = await new Promise((resolve) => canvas.toBlob(resolve, "image/png"));
        if (!blob) {
          throw new Error("export failed");
        }
        const file = new File([blob], `${fileBase || "arena-duo"}.png`, { type: "image/png" });
        if (navigator.share) {
          const canShare = navigator.canShare ? navigator.canShare({ files: [file] }) : true;
          if (canShare) {
            await navigator.share({ files: [file], title: "arena duo report" });
            setStatus("share sheet opened", "status-ok");
            return;
          }
        }
        const url = URL.createObjectURL(blob);
        const link = document.createElement("a");
        link.href = url;
        link.download = file.name;
        document.body.appendChild(link);
        link.click();
        link.remove();
        URL.revokeObjectURL(url);
        setStatus("image downloaded", "status-ok");
      } catch (error) {
        setStatus("image export failed", "status-bad");
      } finally {
        document.body.classList.remove("share-mode");
      }
    }

    let lookupToken = 0;

    async function runLookup(params, attempt = 0, token = null) {
      const currentToken = token || ++lookupToken;
      if (token && token !== lookupToken) return;
      setStatus(attempt ? "rate limited, retrying..." : "loading duo stats", "status-ok");
      dataSource.textContent = "data source: api";
      try {
        const data = await fetchDuoData(params);
        if (currentToken !== lookupToken) return;
        renderAll(data);
      } catch (error) {
        const message = error.message || "api error";
        const isRateLimit = /rate limit/i.test(message);
        if (isRateLimit && attempt < 2 && currentToken === lookupToken) {
          const delay = Math.min(12000, 3000 * (attempt + 1) + Math.floor(Math.random() * 500));
          setStatus(`rate limited, retrying in ${Math.ceil(delay / 1000)}s`, "status-warn");
          setTimeout(() => runLookup(params, attempt + 1, currentToken), delay);
          return;
        }
        renderErrorState(message, params);
      }
    }

    function copyShareUrl() {
      const params = collectParams();
      const url = updateUrl(params);
      if (navigator.clipboard && navigator.clipboard.writeText) {
        navigator.clipboard.writeText(url).then(() => {
          setStatus("share url copied", "status-ok");
        }).catch(() => {
          setStatus("copy failed", "status-bad");
        });
      } else {
        setStatus("copy not supported", "status-bad");
      }
    }

    form.addEventListener("submit", async (event) => {
      event.preventDefault();
      const params = collectParams();
      updateUrl(params);
      await runLookup(params);
    });

    form.addEventListener("reset", () => {
      const params = { ...DEFAULTS };
      applyParams(params);
      updateUrl(params);
      runLookup(params);
    });

    sampleBtn.addEventListener("click", () => {
      const params = { ...DEFAULTS };
      const displayNames = {
        me: displayNameFromInput(params.me) || params.me,
        duo: displayNameFromInput(params.duo) || params.duo
      };
      applyParams(params);
      updateUrl(params);
      renderAll({
        ...demoData,
        meta: {
          ...demoData.meta,
          duo: { me: displayNames.me, duo: displayNames.duo, region: params.region },
          matchCount: Number(params.matches)
        }
      });
      setStatus("demo mode", "status-warn");
    });

    shareBtn.addEventListener("click", copyShareUrl);
    shareImageBtn.addEventListener("click", shareReportImage);

    loadTierList();

    const initialParams = paramsFromUrl();
    applyParams(initialParams);
    updateUrl(initialParams);
    runLookup(initialParams);
  </script>
</body>
</html>
